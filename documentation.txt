Documentation Lab3
Long Tu <longt@andrew.cmu.edu>
Jiang Xue <jiangx@andrew.cmu.edu>
Xuefeng Zhai <xzhai@cmu.edu>
-----------------------------------------------------------------------------------------
Summary:
This document is a brief introduction of the lab 4 design for 18342. It is developed in the following sequences:
First, we talk about how the kernel works and how SWI and IRQ handler works.
Second, we give a detailed specification for each system call and illustrate how it works
Third, we talk about some details of the context switch


-----------------------------------------------------------------------------------------
Kernel:

This kernel installs two customized handlers and realizes five basic system call.
The two handlers are SWI handler and IRQ handler.

The installation is realized in main.c. In main.c, there is a function called wire_in, with two input parameters,  a pointer pointing to a certain address in the VectorTable and the address of my handler. The wire_in function will find out the address of the original handler and modify the first two instructions by which the CPU will jump to our own handler. Additionally, the original first two instructions will be stored in global variables (data section). The return value of wire_in function is -1 when there is an error when installing the handlers. This function is called by kmain, which is the main function of the kernel.

The SWI handler handles a software interrupt, which is raised when a user program calls a system call. The function of SWI handler (s_handler.S and c_swi_handler.c) is restoring r8, enabling irq, storing and restoring the context of a user program, jump to a system call function according to the SWI number.

The IRQ handler handles a timer interrupt, which is raised by the OS timer, built in the processor. The function of IRQ handler (i_handler.S and c_irq_handler.c) is storing and restoring the context of the previous mode (supervisor mode or user mode), checking the source of the interrupt, acknowledging the interrupt to pacify the device if the interrupt is from the OS timer, updating a global variable used for storing the time and restarting the timer. Specifically, when restarting the timer, I rewrite the OSMR with the frequency of the processor divided by 100 (1s=1000ms. 1000ms/10ms=100) and rewrite the OSCR with 0 to make it count from 0 again. This is how the time is counted, i.e. by interrupting the CPU every 10ms and updating the number of 10ms recorded in a global variable in the irq handler. In addition, the irq_handler will call dev_update() to check if the current time equals to the next_match of a device. If so, all the tasks in the sleep queue of that device will be waken up (added to run queue) and the next_match of that device will be updated. Besides, the irq_handler will call dispatch_save() which realizes a function of context switching to the highest priority runnable task if there is.

-----------------------------------------------------------------------------------------
System call:

The nine system calls give the user program chance to use system-level resources.

Time: 
unsigned long time() implements the function of getting the time elapsed since the kernel booted up. It has no input parameter and reruns a unsigned long integer which has a resolution of 10ms. When the function is called, it will get the value of the global variable used for storing time, multiply 10 to this value and return it to the user program.

Sleep: 
void sleep(unsigned long millis) implements the function of suspending the user program for millis milliseconds. When the function is called, it will get the current time (the number of 10ms elapsed since kernel booted up) and plus the value of millis to get the expected time to return to user programs. Then a loop will be executed until the current time (by checking the global variable) exceeds the expected time. And the function returns to handler.

write:
It takes three input, fd, buf and count. fd is the file descriptor. buf is the buffer and count is the number of characters in the buffer. The program first checks if the start address and the end address are in the right location in the memory. Then it handles the short count situation. If all the process works all right. I t would return the number of character it writes. Or else, it would return a "-EFAULT".

Read:
Read System Call implements the following function:
1. Read system call takes three arguments, the file descriptor for reading, a buffer for writing and the number of bytes to read.
2. Return -EBADF for any file descriptor that doesnâ€™t match stdin
3. Return -EFAULT if the memory range specified by the buffer and its maximum size exists outside the range of heap or free part of the SDRAM.
4. Read the user input characters into the buffer from stdin and echo the character back to stdout.
5. If the input has an EOT character, the read system call should return immediately with the number of characters read into the buffer thus far.

Mutex_create
Create a mutex for a task to use and return the number of the mutex.
First find an available mutex by searching for the bAvailable of all the mutex.
If there is no available mutex, return -ENOMEM as an error number.
If an available mutex is funded, mark the bAvailable as FLASE and return the mutex number to the task and the mutex for this task is created.

Mutex_lock
When a task requires to lock a mutex, this function lock the mutex. If the task requires for a mutex that is locked by another task, the task is added to the sleep queue of the mutex.
First this function need to judge if the required mutex is valid, created and the task is not using the mutex. If any of these is not true, return an error number.
Then, if the mutex is currently locked by another task, add the mutex to the sleep queue.
If the mutex is not locked by another task, mark the bLock as True and assign the tasks to the pHolding_tcb of the mutex.
Also, mark the cur_prio of the tasks as 0 to ensure priority inheritance by HLP.

Mutex_unlock
When a task requires to unlock a mutex, this function unlock the mutex.
First this function need to judge if the required mutex is valid, created and the task is not using the mutex. If any of these is not true, return an error number.
Then,  unlock the mutex by marking the bLock as FALSE and pHolding_tcb as NULL. 
If the sleep queue of the mutex is not empty, using runqueue_add() to add the next task to the mutex accruing to priority.
Finally, assign the native_prio to the current_prio of the task to ensure priority inheritance by HLP.

Task Create:
int task_create(task_t * tasks, size_t num_tasks) create a number of tasks specified by user. The function first initialize the run queue and the device, then checks the validation of tasks descriptor passed in from the user and the schedulability of the tasks. Next it initializes the array of tcb based on the tasks descriptor. Finally, it launches the highest priority task. Return error number to the variable errono when error happens, e.g. tasks created out of user space, tasks are not schedulable.

Event Wait:
int event_wait(unsigned int dev), this function puts the task who called into the sleep queue of the device specified by the user (the parameter, dev). Return error number to the variable errno when error happens, e.g. device number is larger than the largest allowed device number.



To make it more clear that how the kernel works. The following statements show the process of how a user program being run in this kernel:

When the kernel is loaded and executed, it starts from start.S and then jumps to the kmain function. In the kamin function, the customized SWI handler and IRQ handler are installed. Then the user stack bottom is set to a3000000 and the arguments are stored into the user stack. The following step is setting the IRQ stack. In my design, the IRQ stack is located in data section. It is implemented by defining a global array of unsigned integer and passing the address of the last element in the array to a function called setup_irq_stack, in which the address is assigned to the stack pointer in IRQ mode.Then the interrupt controller is initialized by disabling the mask of OSTIMER_0 and unsetting the least significant bit of ICLR to make the OSTIMER generate an IRQ interrupt rather than a FRQ interrupt. Next, the timer is initialized, i.e. enabling the interrupt, setting a value (discussed above) into OSMR, and starting counting (writing 0 to OSCR). Then the mutex_init() is called here to initialize all the mutexes. Then the CPU jumps to switchUser function to enable irq and disable frq, to store the context and store the stack pointer to a global variable, to switch to USER Mode and to jump to 0xa0000000 where user program is loaded.

A user program starts from crt0.S, from which CPU will jump to the main function of the user program.

Graph1: How system call works:
#########################################################################################
#                                                                                       #
#--------------call--------------- swi ------------    -----------------                #
#|user program|--->|wrappers: *.S|---->|s_handler.S|-->|c_swi_handler.c| ----> read     #
#--------------    ---------------     -------------   ----------------- ----> write    #
#									 ----> mutex_create   #
#									 ----> mutex_lock   #
#									 ----> mutex_unlock   #
#									 ----> task_create   #
#									 ----> event_wait   #
#									 ----> sleep    #
#									 ----> time     #
#                                                                                       #
#########################################################################################

In a user program, whenever a system function is called, the CPU will switch to SVC mode automatically and execute the customized SWI handler. Then the handler will realize the function discussed in the last section. 

Graph2: How sleep() & time() utilize IRQ:
#################################################################
#			-------------------    checks           #
#			|sleep(), time()  | ------------|       #
#			-------------------             +       #
#							|       #
#     interrupt          call               update      +       #
#--------    ------------    -----------------   -------------	#
#|OStimer|-->|int_asm.S|-->|c_irq_handler.c|-->|num_of_10ms|	#
#--------    ------------    -----------------   -------------	#
#                                                               #
#################################################################

At the same time, every 10ms passed, the OSTIMER_0 will generate an interrupt, and the CPU will go through the irq_wrapper and handle irq interrupts in SVC mode. The c_irq_handler will realize the function discussed in the last section. 

When the user program accidentally returns to crt0.S, it will go into a dead loop.

-------------------------------------------------------------------------------------------
The design of context switch:

Context Switch
â€¢ dispatch_save: save the context of current task and context switch
to highest priority task
â€¢ dispatch_nosave: context switch to the highest priority task
without worrying about saving current taskâ€™s context
â€¢ dispatch_sleep: save current taskâ€™s context, make the current task
not runnable and context switch

ctx_switch_asm.S
â€“ ctx_switch_full will get called from dispatch_save and
dispatch_sleep
â€“ ctx_switch_half will get called from dispatch_nosave

The dispatch_save is called every 10 ms by c_irq_handler.c, then it checks if the current task is the highest priority task in the list. If it is not, the current context would be saved and the highest priority task would be removed from the runnable queue and get executed
The dispatch_nosave is called once at the beginning, just to load register values into memory. 

During the initialization, we set the value of lr to be the address of launch_task. so that for the first time a task is executed, it would go to the launch task to have an initial value of its registers. After that, it would retrive its value from the its context in tcb struct.
